import { ChangeDetectorRef, EventEmitter, OnChanges, OnDestroy, SimpleChanges } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { TimepickerActions } from './reducer/timepicker.actions';
import { TimepickerStore } from './reducer/timepicker.store';
import { TimepickerConfig } from './timepicker.config';
import { TimeChangeSource, TimepickerComponentState, TimepickerControls } from './timepicker.models';
import { Subscription } from 'rxjs';
import { ControlValueAccessorModel } from './models';
import * as ɵngcc0 from '@angular/core';
export declare const TIMEPICKER_CONTROL_VALUE_ACCESSOR: ControlValueAccessorModel;
export declare class TimepickerComponent implements ControlValueAccessor, TimepickerComponentState, TimepickerControls, OnChanges, OnDestroy {
    private _cd;
    private _store;
    private _timepickerActions;
    /** hours change step */
    hourStep: number;
    /** hours change step */
    minuteStep: number;
    /** seconds change step */
    secondsStep: number;
    /** if true hours and minutes fields will be readonly */
    readonlyInput: boolean;
    /** if true hours and minutes fields will be disabled */
    disabled: boolean;
    /** if true scroll inside hours and minutes inputs will change time */
    mousewheel: boolean;
    /** if true the values of hours and minutes can be changed using the up/down arrow keys on the keyboard */
    arrowkeys: boolean;
    /** if true spinner arrows above and below the inputs will be shown */
    showSpinners: boolean;
    /** if true meridian button will be shown */
    showMeridian: boolean;
    /** show minutes in timepicker */
    showMinutes: boolean;
    /** show seconds in timepicker */
    showSeconds: boolean;
    /** meridian labels based on locale */
    meridians: string[];
    /** minimum time user can select */
    min: Date;
    /** maximum time user can select */
    max: Date;
    /** placeholder for hours field in timepicker */
    hoursPlaceholder: string;
    /** placeholder for minutes field in timepicker */
    minutesPlaceholder: string;
    /** placeholder for seconds field in timepicker */
    secondsPlaceholder: string;
    /** emits true if value is a valid date */
    isValid: EventEmitter<boolean>;
    hours: string;
    minutes: string;
    seconds: string;
    meridian: string;
    /** @deprecated - please use `isEditable` instead */
    readonly isSpinnersVisible: boolean;
    readonly isEditable: boolean;
    invalidHours: boolean;
    invalidMinutes: boolean;
    invalidSeconds: boolean;
    labelHours: string;
    labelMinutes: string;
    labelSeconds: string;
    canIncrementHours: boolean;
    canIncrementMinutes: boolean;
    canIncrementSeconds: boolean;
    canDecrementHours: boolean;
    canDecrementMinutes: boolean;
    canDecrementSeconds: boolean;
    canToggleMeridian: boolean;
    onChange: Function;
    onTouched: Function;
    timepickerSub: Subscription;
    constructor(_config: TimepickerConfig, _cd: ChangeDetectorRef, _store: TimepickerStore, _timepickerActions: TimepickerActions);
    resetValidation(): void;
    isPM(): boolean;
    prevDef($event: Event): void;
    wheelSign($event: WheelEventInit): number;
    ngOnChanges(changes: SimpleChanges): void;
    changeHours(step: number, source?: TimeChangeSource): void;
    changeMinutes(step: number, source?: TimeChangeSource): void;
    changeSeconds(step: number, source?: TimeChangeSource): void;
    updateHours(hours: string): void;
    updateMinutes(minutes: string): void;
    updateSeconds(seconds: string): void;
    isValidLimit(): boolean;
    _updateTime(): void;
    toggleMeridian(): void;
    /**
     * Write a new value to the element.
     */
    writeValue(obj: string | null | undefined | Date): void;
    /**
     * Set the function to be called when the control receives a change event.
     */
    registerOnChange(fn: (_: any) => {}): void;
    /**
     * Set the function to be called when the control receives a touch event.
     */
    registerOnTouched(fn: () => {}): void;
    /**
     * This function is called when the control status changes to or from "disabled".
     * Depending on the value, it will enable or disable the appropriate DOM element.
     *
     * @param isDisabled
     */
    setDisabledState(isDisabled: boolean): void;
    ngOnDestroy(): void;
    private _renderTime;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<TimepickerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<TimepickerComponent, "timepicker", never, { "disabled": "disabled"; "hourStep": "hourStep"; "minuteStep": "minuteStep"; "secondsStep": "secondsStep"; "readonlyInput": "readonlyInput"; "mousewheel": "mousewheel"; "arrowkeys": "arrowkeys"; "showSpinners": "showSpinners"; "showMeridian": "showMeridian"; "showMinutes": "showMinutes"; "showSeconds": "showSeconds"; "meridians": "meridians"; "min": "min"; "max": "max"; "hoursPlaceholder": "hoursPlaceholder"; "minutesPlaceholder": "minutesPlaceholder"; "secondsPlaceholder": "secondsPlaceholder"; }, { "isValid": "isValid"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXBpY2tlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsidGltZXBpY2tlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBFdmVudEVtaXR0ZXIsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFRpbWVwaWNrZXJBY3Rpb25zIH0gZnJvbSAnLi9yZWR1Y2VyL3RpbWVwaWNrZXIuYWN0aW9ucyc7XG5pbXBvcnQgeyBUaW1lcGlja2VyU3RvcmUgfSBmcm9tICcuL3JlZHVjZXIvdGltZXBpY2tlci5zdG9yZSc7XG5pbXBvcnQgeyBUaW1lcGlja2VyQ29uZmlnIH0gZnJvbSAnLi90aW1lcGlja2VyLmNvbmZpZyc7XG5pbXBvcnQgeyBUaW1lQ2hhbmdlU291cmNlLCBUaW1lcGlja2VyQ29tcG9uZW50U3RhdGUsIFRpbWVwaWNrZXJDb250cm9scyB9IGZyb20gJy4vdGltZXBpY2tlci5tb2RlbHMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3Nvck1vZGVsIH0gZnJvbSAnLi9tb2RlbHMnO1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgVElNRVBJQ0tFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBDb250cm9sVmFsdWVBY2Nlc3Nvck1vZGVsO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgVGltZXBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBUaW1lcGlja2VyQ29tcG9uZW50U3RhdGUsIFRpbWVwaWNrZXJDb250cm9scywgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX2NkO1xuICAgIHByaXZhdGUgX3N0b3JlO1xuICAgIHByaXZhdGUgX3RpbWVwaWNrZXJBY3Rpb25zO1xuICAgIC8qKiBob3VycyBjaGFuZ2Ugc3RlcCAqL1xuICAgIGhvdXJTdGVwOiBudW1iZXI7XG4gICAgLyoqIGhvdXJzIGNoYW5nZSBzdGVwICovXG4gICAgbWludXRlU3RlcDogbnVtYmVyO1xuICAgIC8qKiBzZWNvbmRzIGNoYW5nZSBzdGVwICovXG4gICAgc2Vjb25kc1N0ZXA6IG51bWJlcjtcbiAgICAvKiogaWYgdHJ1ZSBob3VycyBhbmQgbWludXRlcyBmaWVsZHMgd2lsbCBiZSByZWFkb25seSAqL1xuICAgIHJlYWRvbmx5SW5wdXQ6IGJvb2xlYW47XG4gICAgLyoqIGlmIHRydWUgaG91cnMgYW5kIG1pbnV0ZXMgZmllbGRzIHdpbGwgYmUgZGlzYWJsZWQgKi9cbiAgICBkaXNhYmxlZDogYm9vbGVhbjtcbiAgICAvKiogaWYgdHJ1ZSBzY3JvbGwgaW5zaWRlIGhvdXJzIGFuZCBtaW51dGVzIGlucHV0cyB3aWxsIGNoYW5nZSB0aW1lICovXG4gICAgbW91c2V3aGVlbDogYm9vbGVhbjtcbiAgICAvKiogaWYgdHJ1ZSB0aGUgdmFsdWVzIG9mIGhvdXJzIGFuZCBtaW51dGVzIGNhbiBiZSBjaGFuZ2VkIHVzaW5nIHRoZSB1cC9kb3duIGFycm93IGtleXMgb24gdGhlIGtleWJvYXJkICovXG4gICAgYXJyb3drZXlzOiBib29sZWFuO1xuICAgIC8qKiBpZiB0cnVlIHNwaW5uZXIgYXJyb3dzIGFib3ZlIGFuZCBiZWxvdyB0aGUgaW5wdXRzIHdpbGwgYmUgc2hvd24gKi9cbiAgICBzaG93U3Bpbm5lcnM6IGJvb2xlYW47XG4gICAgLyoqIGlmIHRydWUgbWVyaWRpYW4gYnV0dG9uIHdpbGwgYmUgc2hvd24gKi9cbiAgICBzaG93TWVyaWRpYW46IGJvb2xlYW47XG4gICAgLyoqIHNob3cgbWludXRlcyBpbiB0aW1lcGlja2VyICovXG4gICAgc2hvd01pbnV0ZXM6IGJvb2xlYW47XG4gICAgLyoqIHNob3cgc2Vjb25kcyBpbiB0aW1lcGlja2VyICovXG4gICAgc2hvd1NlY29uZHM6IGJvb2xlYW47XG4gICAgLyoqIG1lcmlkaWFuIGxhYmVscyBiYXNlZCBvbiBsb2NhbGUgKi9cbiAgICBtZXJpZGlhbnM6IHN0cmluZ1tdO1xuICAgIC8qKiBtaW5pbXVtIHRpbWUgdXNlciBjYW4gc2VsZWN0ICovXG4gICAgbWluOiBEYXRlO1xuICAgIC8qKiBtYXhpbXVtIHRpbWUgdXNlciBjYW4gc2VsZWN0ICovXG4gICAgbWF4OiBEYXRlO1xuICAgIC8qKiBwbGFjZWhvbGRlciBmb3IgaG91cnMgZmllbGQgaW4gdGltZXBpY2tlciAqL1xuICAgIGhvdXJzUGxhY2Vob2xkZXI6IHN0cmluZztcbiAgICAvKiogcGxhY2Vob2xkZXIgZm9yIG1pbnV0ZXMgZmllbGQgaW4gdGltZXBpY2tlciAqL1xuICAgIG1pbnV0ZXNQbGFjZWhvbGRlcjogc3RyaW5nO1xuICAgIC8qKiBwbGFjZWhvbGRlciBmb3Igc2Vjb25kcyBmaWVsZCBpbiB0aW1lcGlja2VyICovXG4gICAgc2Vjb25kc1BsYWNlaG9sZGVyOiBzdHJpbmc7XG4gICAgLyoqIGVtaXRzIHRydWUgaWYgdmFsdWUgaXMgYSB2YWxpZCBkYXRlICovXG4gICAgaXNWYWxpZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+O1xuICAgIGhvdXJzOiBzdHJpbmc7XG4gICAgbWludXRlczogc3RyaW5nO1xuICAgIHNlY29uZHM6IHN0cmluZztcbiAgICBtZXJpZGlhbjogc3RyaW5nO1xuICAgIC8qKiBAZGVwcmVjYXRlZCAtIHBsZWFzZSB1c2UgYGlzRWRpdGFibGVgIGluc3RlYWQgKi9cbiAgICByZWFkb25seSBpc1NwaW5uZXJzVmlzaWJsZTogYm9vbGVhbjtcbiAgICByZWFkb25seSBpc0VkaXRhYmxlOiBib29sZWFuO1xuICAgIGludmFsaWRIb3VyczogYm9vbGVhbjtcbiAgICBpbnZhbGlkTWludXRlczogYm9vbGVhbjtcbiAgICBpbnZhbGlkU2Vjb25kczogYm9vbGVhbjtcbiAgICBsYWJlbEhvdXJzOiBzdHJpbmc7XG4gICAgbGFiZWxNaW51dGVzOiBzdHJpbmc7XG4gICAgbGFiZWxTZWNvbmRzOiBzdHJpbmc7XG4gICAgY2FuSW5jcmVtZW50SG91cnM6IGJvb2xlYW47XG4gICAgY2FuSW5jcmVtZW50TWludXRlczogYm9vbGVhbjtcbiAgICBjYW5JbmNyZW1lbnRTZWNvbmRzOiBib29sZWFuO1xuICAgIGNhbkRlY3JlbWVudEhvdXJzOiBib29sZWFuO1xuICAgIGNhbkRlY3JlbWVudE1pbnV0ZXM6IGJvb2xlYW47XG4gICAgY2FuRGVjcmVtZW50U2Vjb25kczogYm9vbGVhbjtcbiAgICBjYW5Ub2dnbGVNZXJpZGlhbjogYm9vbGVhbjtcbiAgICBvbkNoYW5nZTogRnVuY3Rpb247XG4gICAgb25Ub3VjaGVkOiBGdW5jdGlvbjtcbiAgICB0aW1lcGlja2VyU3ViOiBTdWJzY3JpcHRpb247XG4gICAgY29uc3RydWN0b3IoX2NvbmZpZzogVGltZXBpY2tlckNvbmZpZywgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZiwgX3N0b3JlOiBUaW1lcGlja2VyU3RvcmUsIF90aW1lcGlja2VyQWN0aW9uczogVGltZXBpY2tlckFjdGlvbnMpO1xuICAgIHJlc2V0VmFsaWRhdGlvbigpOiB2b2lkO1xuICAgIGlzUE0oKTogYm9vbGVhbjtcbiAgICBwcmV2RGVmKCRldmVudDogRXZlbnQpOiB2b2lkO1xuICAgIHdoZWVsU2lnbigkZXZlbnQ6IFdoZWVsRXZlbnRJbml0KTogbnVtYmVyO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIGNoYW5nZUhvdXJzKHN0ZXA6IG51bWJlciwgc291cmNlPzogVGltZUNoYW5nZVNvdXJjZSk6IHZvaWQ7XG4gICAgY2hhbmdlTWludXRlcyhzdGVwOiBudW1iZXIsIHNvdXJjZT86IFRpbWVDaGFuZ2VTb3VyY2UpOiB2b2lkO1xuICAgIGNoYW5nZVNlY29uZHMoc3RlcDogbnVtYmVyLCBzb3VyY2U/OiBUaW1lQ2hhbmdlU291cmNlKTogdm9pZDtcbiAgICB1cGRhdGVIb3Vycyhob3Vyczogc3RyaW5nKTogdm9pZDtcbiAgICB1cGRhdGVNaW51dGVzKG1pbnV0ZXM6IHN0cmluZyk6IHZvaWQ7XG4gICAgdXBkYXRlU2Vjb25kcyhzZWNvbmRzOiBzdHJpbmcpOiB2b2lkO1xuICAgIGlzVmFsaWRMaW1pdCgpOiBib29sZWFuO1xuICAgIF91cGRhdGVUaW1lKCk6IHZvaWQ7XG4gICAgdG9nZ2xlTWVyaWRpYW4oKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIG5ldyB2YWx1ZSB0byB0aGUgZWxlbWVudC5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKG9iajogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCB8IERhdGUpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgcmVjZWl2ZXMgYSBjaGFuZ2UgZXZlbnQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4ge30pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgcmVjZWl2ZXMgYSB0b3VjaCBldmVudC5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4ge30pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgc3RhdHVzIGNoYW5nZXMgdG8gb3IgZnJvbSBcImRpc2FibGVkXCIuXG4gICAgICogRGVwZW5kaW5nIG9uIHRoZSB2YWx1ZSwgaXQgd2lsbCBlbmFibGUgb3IgZGlzYWJsZSB0aGUgYXBwcm9wcmlhdGUgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXNEaXNhYmxlZFxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICBwcml2YXRlIF9yZW5kZXJUaW1lO1xufVxuIl19