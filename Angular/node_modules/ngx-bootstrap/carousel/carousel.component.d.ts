/***
 * pause (not yet supported) (?string='hover') - event group name which pauses
 * the cycling of the carousel, if hover pauses on mouseenter and resumes on
 * mouseleave keyboard (not yet supported) (?boolean=true) - if false
 * carousel will not react to keyboard events
 * note: swiping not yet supported
 */
/****
 * Problems:
 * 1) if we set an active slide via model changes, .active class remains on a
 * current slide.
 * 2) if we have only one slide, we shouldn't show prev/next nav buttons
 * 3) if first or last slide is active and noWrap is true, there should be
 * "disabled" class on the nav buttons.
 * 4) default interval should be equal 5000
 */
import { EventEmitter, NgZone, OnDestroy, AfterViewInit } from '@angular/core';
import { LinkedList } from 'ngx-bootstrap/utils';
import { SlideComponent } from './slide.component';
import { CarouselConfig } from './carousel.config';
import { SlideWithIndex } from './models';
import * as ɵngcc0 from '@angular/core';
export declare enum Direction {
    UNKNOWN = 0,
    NEXT = 1,
    PREV = 2
}
/**
 * Base element to create carousel
 */
export declare class CarouselComponent implements AfterViewInit, OnDestroy {
    private ngZone;
    noWrap: boolean;
    noPause: boolean;
    showIndicators: boolean;
    pauseOnFocus: boolean;
    indicatorsByChunk: boolean;
    itemsPerSlide: number;
    singleSlideOffset: boolean;
    /** Turn on/off animation. Animation doesn't work for multilist carousel */
    isAnimated: boolean;
    /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */
    activeSlideChange: EventEmitter<number>;
    /** Will be emitted when active slides has been changed in multilist mode */
    slideRangeChange: EventEmitter<number[]>;
    /** Index of currently displayed slide(started for 0) */
    activeSlide: number;
    startFromIndex: number;
    /**
     * Delay of item cycling in milliseconds. If false, carousel won't cycle
     * automatically.
     */
    interval: number;
    readonly slides: SlideComponent[];
    protected currentInterval: any;
    protected _currentActiveSlide: number;
    protected _interval: number;
    protected _slides: LinkedList<SlideComponent>;
    protected _chunkedSlides: SlideWithIndex[][];
    protected _slidesWithIndexes: SlideWithIndex[];
    protected _currentVisibleSlidesIndex: number;
    protected isPlaying: boolean;
    protected destroyed: boolean;
    readonly isBs4: boolean;
    constructor(config: CarouselConfig, ngZone: NgZone);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Adds new slide. If this slide is first in collection - set it as active
     * and starts auto changing
     * @param slide
     */
    addSlide(slide: SlideComponent): void;
    /**
     * Removes specified slide. If this slide is active - will roll to another
     * slide
     * @param slide
     */
    removeSlide(slide: SlideComponent): void;
    nextSlideFromInterval(force?: boolean): void;
    /**
     * Rolling to next slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    nextSlide(force?: boolean): void;
    /**
     * Rolling to previous slide
     * @param force: {boolean} if true - will ignore noWrap flag
     */
    previousSlide(force?: boolean): void;
    getFirstVisibleIndex(): number;
    getLastVisibleIndex(): number;
    getActive: (slide: SlideComponent) => boolean;
    move(direction: Direction, force?: boolean): void;
    /**
     * Swith slides by enter, space and arrows keys
     * @internal
     */
    keydownPress(event: KeyboardEvent): void;
    /**
     * Play on mouse leave
     * @internal
     */
    onMouseLeave(): void;
    /**
     * Play on mouse up
     * @internal
     */
    onMouseUp(): void;
    /**
     * When slides on focus autoplay is stopped(optional)
     * @internal
     */
    pauseFocusIn(): void;
    /**
     * When slides out of focus autoplay is started
     * @internal
     */
    pauseFocusOut(): void;
    /**
     * Rolling to specified slide
     * @param index: {number} index of slide, which must be shown
     */
    selectSlide(index: number): void;
    /**
     * Starts a auto changing of slides
     */
    play(): void;
    /**
     * Stops a auto changing of slides
     */
    pause(): void;
    /**
     * Finds and returns index of currently displayed slide
     */
    getCurrentSlideIndex(): number;
    /**
     * Defines, whether the specified index is last in collection
     * @param index
     */
    isLast(index: number): boolean;
    /**
     * Defines, whether the specified index is first in collection
     * @param index
     */
    isFirst(index: number): boolean;
    indicatorsSlides(): SlideComponent[];
    private selectInitialSlides;
    /**
     * Defines next slide index, depending of direction
     * @param direction: Direction(UNKNOWN|PREV|NEXT)
     * @param force: {boolean} if TRUE - will ignore noWrap flag, else will
     *   return undefined if next slide require wrapping
     */
    private findNextSlideIndex;
    private mapSlidesAndIndexes;
    private selectSlideRange;
    private selectRangeByNestedIndex;
    private isIndexOnTheEdges;
    private isIndexInRange;
    private hideSlides;
    private isVisibleSlideListLast;
    private isVisibleSlideListFirst;
    private moveSliderByOneItem;
    private makeSlidesConsistent;
    private moveMultilist;
    private getVisibleIndexes;
    /**
     * Sets a slide, which specified through index, as active
     * @param index
     */
    private _select;
    /**
     * Starts loop of auto changing of slides
     */
    private restartTimer;
    readonly multilist: boolean;
    /**
     * Stops loop of auto changing of slides
     */
    private resetTimer;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CarouselComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CarouselComponent, "carousel", never, { "indicatorsByChunk": "indicatorsByChunk"; "itemsPerSlide": "itemsPerSlide"; "singleSlideOffset": "singleSlideOffset"; "isAnimated": "isAnimated"; "startFromIndex": "startFromIndex"; "activeSlide": "activeSlide"; "interval": "interval"; "noWrap": "noWrap"; "noPause": "noPause"; "showIndicators": "showIndicators"; "pauseOnFocus": "pauseOnFocus"; }, { "activeSlideChange": "activeSlideChange"; "slideRangeChange": "slideRangeChange"; }, never, ["*"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNhcm91c2VsLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqKlxuICogcGF1c2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSAoP3N0cmluZz0naG92ZXInKSAtIGV2ZW50IGdyb3VwIG5hbWUgd2hpY2ggcGF1c2VzXG4gKiB0aGUgY3ljbGluZyBvZiB0aGUgY2Fyb3VzZWwsIGlmIGhvdmVyIHBhdXNlcyBvbiBtb3VzZWVudGVyIGFuZCByZXN1bWVzIG9uXG4gKiBtb3VzZWxlYXZlIGtleWJvYXJkIChub3QgeWV0IHN1cHBvcnRlZCkgKD9ib29sZWFuPXRydWUpIC0gaWYgZmFsc2VcbiAqIGNhcm91c2VsIHdpbGwgbm90IHJlYWN0IHRvIGtleWJvYXJkIGV2ZW50c1xuICogbm90ZTogc3dpcGluZyBub3QgeWV0IHN1cHBvcnRlZFxuICovXG4vKioqKlxuICogUHJvYmxlbXM6XG4gKiAxKSBpZiB3ZSBzZXQgYW4gYWN0aXZlIHNsaWRlIHZpYSBtb2RlbCBjaGFuZ2VzLCAuYWN0aXZlIGNsYXNzIHJlbWFpbnMgb24gYVxuICogY3VycmVudCBzbGlkZS5cbiAqIDIpIGlmIHdlIGhhdmUgb25seSBvbmUgc2xpZGUsIHdlIHNob3VsZG4ndCBzaG93IHByZXYvbmV4dCBuYXYgYnV0dG9uc1xuICogMykgaWYgZmlyc3Qgb3IgbGFzdCBzbGlkZSBpcyBhY3RpdmUgYW5kIG5vV3JhcCBpcyB0cnVlLCB0aGVyZSBzaG91bGQgYmVcbiAqIFwiZGlzYWJsZWRcIiBjbGFzcyBvbiB0aGUgbmF2IGJ1dHRvbnMuXG4gKiA0KSBkZWZhdWx0IGludGVydmFsIHNob3VsZCBiZSBlcXVhbCA1MDAwXG4gKi9cbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgTmdab25lLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICduZ3gtYm9vdHN0cmFwL3V0aWxzJztcbmltcG9ydCB7IFNsaWRlQ29tcG9uZW50IH0gZnJvbSAnLi9zbGlkZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2Fyb3VzZWxDb25maWcgfSBmcm9tICcuL2Nhcm91c2VsLmNvbmZpZyc7XG5pbXBvcnQgeyBTbGlkZVdpdGhJbmRleCB9IGZyb20gJy4vbW9kZWxzJztcbmV4cG9ydCBkZWNsYXJlIGVudW0gRGlyZWN0aW9uIHtcbiAgICBVTktOT1dOID0gMCxcbiAgICBORVhUID0gMSxcbiAgICBQUkVWID0gMlxufVxuLyoqXG4gKiBCYXNlIGVsZW1lbnQgdG8gY3JlYXRlIGNhcm91c2VsXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIENhcm91c2VsQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIG5nWm9uZTtcbiAgICBub1dyYXA6IGJvb2xlYW47XG4gICAgbm9QYXVzZTogYm9vbGVhbjtcbiAgICBzaG93SW5kaWNhdG9yczogYm9vbGVhbjtcbiAgICBwYXVzZU9uRm9jdXM6IGJvb2xlYW47XG4gICAgaW5kaWNhdG9yc0J5Q2h1bms6IGJvb2xlYW47XG4gICAgaXRlbXNQZXJTbGlkZTogbnVtYmVyO1xuICAgIHNpbmdsZVNsaWRlT2Zmc2V0OiBib29sZWFuO1xuICAgIC8qKiBUdXJuIG9uL29mZiBhbmltYXRpb24uIEFuaW1hdGlvbiBkb2Vzbid0IHdvcmsgZm9yIG11bHRpbGlzdCBjYXJvdXNlbCAqL1xuICAgIGlzQW5pbWF0ZWQ6IGJvb2xlYW47XG4gICAgLyoqIFdpbGwgYmUgZW1pdHRlZCB3aGVuIGFjdGl2ZSBzbGlkZSBoYXMgYmVlbiBjaGFuZ2VkLiBQYXJ0IG9mIHR3by13YXktYmluZGFibGUgWyhhY3RpdmVTbGlkZSldIHByb3BlcnR5ICovXG4gICAgYWN0aXZlU2xpZGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxudW1iZXI+O1xuICAgIC8qKiBXaWxsIGJlIGVtaXR0ZWQgd2hlbiBhY3RpdmUgc2xpZGVzIGhhcyBiZWVuIGNoYW5nZWQgaW4gbXVsdGlsaXN0IG1vZGUgKi9cbiAgICBzbGlkZVJhbmdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyW10+O1xuICAgIC8qKiBJbmRleCBvZiBjdXJyZW50bHkgZGlzcGxheWVkIHNsaWRlKHN0YXJ0ZWQgZm9yIDApICovXG4gICAgYWN0aXZlU2xpZGU6IG51bWJlcjtcbiAgICBzdGFydEZyb21JbmRleDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlbGF5IG9mIGl0ZW0gY3ljbGluZyBpbiBtaWxsaXNlY29uZHMuIElmIGZhbHNlLCBjYXJvdXNlbCB3b24ndCBjeWNsZVxuICAgICAqIGF1dG9tYXRpY2FsbHkuXG4gICAgICovXG4gICAgaW50ZXJ2YWw6IG51bWJlcjtcbiAgICByZWFkb25seSBzbGlkZXM6IFNsaWRlQ29tcG9uZW50W107XG4gICAgcHJvdGVjdGVkIGN1cnJlbnRJbnRlcnZhbDogYW55O1xuICAgIHByb3RlY3RlZCBfY3VycmVudEFjdGl2ZVNsaWRlOiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9pbnRlcnZhbDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBfc2xpZGVzOiBMaW5rZWRMaXN0PFNsaWRlQ29tcG9uZW50PjtcbiAgICBwcm90ZWN0ZWQgX2NodW5rZWRTbGlkZXM6IFNsaWRlV2l0aEluZGV4W11bXTtcbiAgICBwcm90ZWN0ZWQgX3NsaWRlc1dpdGhJbmRleGVzOiBTbGlkZVdpdGhJbmRleFtdO1xuICAgIHByb3RlY3RlZCBfY3VycmVudFZpc2libGVTbGlkZXNJbmRleDogbnVtYmVyO1xuICAgIHByb3RlY3RlZCBpc1BsYXlpbmc6IGJvb2xlYW47XG4gICAgcHJvdGVjdGVkIGRlc3Ryb3llZDogYm9vbGVhbjtcbiAgICByZWFkb25seSBpc0JzNDogYm9vbGVhbjtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWc6IENhcm91c2VsQ29uZmlnLCBuZ1pvbmU6IE5nWm9uZSk7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBzbGlkZS4gSWYgdGhpcyBzbGlkZSBpcyBmaXJzdCBpbiBjb2xsZWN0aW9uIC0gc2V0IGl0IGFzIGFjdGl2ZVxuICAgICAqIGFuZCBzdGFydHMgYXV0byBjaGFuZ2luZ1xuICAgICAqIEBwYXJhbSBzbGlkZVxuICAgICAqL1xuICAgIGFkZFNsaWRlKHNsaWRlOiBTbGlkZUNvbXBvbmVudCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBzcGVjaWZpZWQgc2xpZGUuIElmIHRoaXMgc2xpZGUgaXMgYWN0aXZlIC0gd2lsbCByb2xsIHRvIGFub3RoZXJcbiAgICAgKiBzbGlkZVxuICAgICAqIEBwYXJhbSBzbGlkZVxuICAgICAqL1xuICAgIHJlbW92ZVNsaWRlKHNsaWRlOiBTbGlkZUNvbXBvbmVudCk6IHZvaWQ7XG4gICAgbmV4dFNsaWRlRnJvbUludGVydmFsKGZvcmNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBuZXh0IHNsaWRlXG4gICAgICogQHBhcmFtIGZvcmNlOiB7Ym9vbGVhbn0gaWYgdHJ1ZSAtIHdpbGwgaWdub3JlIG5vV3JhcCBmbGFnXG4gICAgICovXG4gICAgbmV4dFNsaWRlKGZvcmNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUm9sbGluZyB0byBwcmV2aW91cyBzbGlkZVxuICAgICAqIEBwYXJhbSBmb3JjZToge2Jvb2xlYW59IGlmIHRydWUgLSB3aWxsIGlnbm9yZSBub1dyYXAgZmxhZ1xuICAgICAqL1xuICAgIHByZXZpb3VzU2xpZGUoZm9yY2U/OiBib29sZWFuKTogdm9pZDtcbiAgICBnZXRGaXJzdFZpc2libGVJbmRleCgpOiBudW1iZXI7XG4gICAgZ2V0TGFzdFZpc2libGVJbmRleCgpOiBudW1iZXI7XG4gICAgZ2V0QWN0aXZlOiAoc2xpZGU6IFNsaWRlQ29tcG9uZW50KSA9PiBib29sZWFuO1xuICAgIG1vdmUoZGlyZWN0aW9uOiBEaXJlY3Rpb24sIGZvcmNlPzogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogU3dpdGggc2xpZGVzIGJ5IGVudGVyLCBzcGFjZSBhbmQgYXJyb3dzIGtleXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBrZXlkb3duUHJlc3MoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBsYXkgb24gbW91c2UgbGVhdmVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBvbk1vdXNlTGVhdmUoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBQbGF5IG9uIG1vdXNlIHVwXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb25Nb3VzZVVwKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogV2hlbiBzbGlkZXMgb24gZm9jdXMgYXV0b3BsYXkgaXMgc3RvcHBlZChvcHRpb25hbClcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXVzZUZvY3VzSW4oKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXaGVuIHNsaWRlcyBvdXQgb2YgZm9jdXMgYXV0b3BsYXkgaXMgc3RhcnRlZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHBhdXNlRm9jdXNPdXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSb2xsaW5nIHRvIHNwZWNpZmllZCBzbGlkZVxuICAgICAqIEBwYXJhbSBpbmRleDoge251bWJlcn0gaW5kZXggb2Ygc2xpZGUsIHdoaWNoIG11c3QgYmUgc2hvd25cbiAgICAgKi9cbiAgICBzZWxlY3RTbGlkZShpbmRleDogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqL1xuICAgIHBsYXkoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBhIGF1dG8gY2hhbmdpbmcgb2Ygc2xpZGVzXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgcmV0dXJucyBpbmRleCBvZiBjdXJyZW50bHkgZGlzcGxheWVkIHNsaWRlXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFNsaWRlSW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMsIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBsYXN0IGluIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBpc0xhc3QoaW5kZXg6IG51bWJlcik6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGVmaW5lcywgd2hldGhlciB0aGUgc3BlY2lmaWVkIGluZGV4IGlzIGZpcnN0IGluIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBpc0ZpcnN0KGluZGV4OiBudW1iZXIpOiBib29sZWFuO1xuICAgIGluZGljYXRvcnNTbGlkZXMoKTogU2xpZGVDb21wb25lbnRbXTtcbiAgICBwcml2YXRlIHNlbGVjdEluaXRpYWxTbGlkZXM7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBuZXh0IHNsaWRlIGluZGV4LCBkZXBlbmRpbmcgb2YgZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIGRpcmVjdGlvbjogRGlyZWN0aW9uKFVOS05PV058UFJFVnxORVhUKVxuICAgICAqIEBwYXJhbSBmb3JjZToge2Jvb2xlYW59IGlmIFRSVUUgLSB3aWxsIGlnbm9yZSBub1dyYXAgZmxhZywgZWxzZSB3aWxsXG4gICAgICogICByZXR1cm4gdW5kZWZpbmVkIGlmIG5leHQgc2xpZGUgcmVxdWlyZSB3cmFwcGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgZmluZE5leHRTbGlkZUluZGV4O1xuICAgIHByaXZhdGUgbWFwU2xpZGVzQW5kSW5kZXhlcztcbiAgICBwcml2YXRlIHNlbGVjdFNsaWRlUmFuZ2U7XG4gICAgcHJpdmF0ZSBzZWxlY3RSYW5nZUJ5TmVzdGVkSW5kZXg7XG4gICAgcHJpdmF0ZSBpc0luZGV4T25UaGVFZGdlcztcbiAgICBwcml2YXRlIGlzSW5kZXhJblJhbmdlO1xuICAgIHByaXZhdGUgaGlkZVNsaWRlcztcbiAgICBwcml2YXRlIGlzVmlzaWJsZVNsaWRlTGlzdExhc3Q7XG4gICAgcHJpdmF0ZSBpc1Zpc2libGVTbGlkZUxpc3RGaXJzdDtcbiAgICBwcml2YXRlIG1vdmVTbGlkZXJCeU9uZUl0ZW07XG4gICAgcHJpdmF0ZSBtYWtlU2xpZGVzQ29uc2lzdGVudDtcbiAgICBwcml2YXRlIG1vdmVNdWx0aWxpc3Q7XG4gICAgcHJpdmF0ZSBnZXRWaXNpYmxlSW5kZXhlcztcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgc2xpZGUsIHdoaWNoIHNwZWNpZmllZCB0aHJvdWdoIGluZGV4LCBhcyBhY3RpdmVcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zZWxlY3Q7XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGxvb3Agb2YgYXV0byBjaGFuZ2luZyBvZiBzbGlkZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlc3RhcnRUaW1lcjtcbiAgICByZWFkb25seSBtdWx0aWxpc3Q6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3RvcHMgbG9vcCBvZiBhdXRvIGNoYW5naW5nIG9mIHNsaWRlc1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRUaW1lcjtcbn1cbiJdfQ==