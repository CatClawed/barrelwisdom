import { EventEmitter, Provider } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { DatePickerInnerComponent } from './datepicker-inner.component';
import { DatepickerConfig } from './datepicker.config';
import * as ɵngcc0 from '@angular/core';
export declare const DATEPICKER_CONTROL_VALUE_ACCESSOR: Provider;
export declare class DatePickerComponent implements ControlValueAccessor {
    /** sets datepicker mode, supports: `day`, `month`, `year` */
    datepickerMode: string;
    /** default date to show if `ng-model` value is not specified */
    initDate: Date;
    /**  oldest selectable date */
    minDate: Date;
    /** latest selectable date */
    maxDate: Date;
    /** set lower datepicker mode, supports: `day`, `month`, `year` */
    minMode: string;
    /** sets upper datepicker mode, supports: `day`, `month`, `year` */
    maxMode: string;
    /** if false week numbers will be hidden */
    showWeeks: boolean;
    /** format of day in month */
    formatDay: string;
    /** format of month in year */
    formatMonth: string;
    /** format of year in year range */
    formatYear: string;
    /** format of day in week header */
    formatDayHeader: string;
    /** format of title when selecting day */
    formatDayTitle: string;
    /** format of title when selecting month */
    formatMonthTitle: string;
    /** starting day of the week from 0-6 (0=Sunday, ..., 6=Saturday) */
    startingDay: number;
    /** number of years displayed in year selection */
    yearRange: number;
    /** if true only dates from the currently displayed month will be shown */
    onlyCurrentMonth: boolean;
    /** if true shortcut`s event propagation will be disabled */
    shortcutPropagation: boolean;
    /** number of months displayed in a single row of month picker */
    monthColLimit: number;
    /** number of years displayed in a single row of year picker */
    yearColLimit: number;
    /** array of custom css classes to be applied to targeted dates */
    customClass: {
        date: Date;
        mode: string;
        clazz: string;
    }[];
    /** array of disabled dates */
    dateDisabled: {
        date: Date;
        mode: string;
    }[];
    /** disabled days of the week from 0-6 (0=Sunday, ..., 6=Saturday) */
    dayDisabled: number[];
    /** currently active date */
    activeDate: Date;
    selectionDone: EventEmitter<Date>;
    /** callback to invoke when the activeDate is changed. */
    activeDateChange: EventEmitter<Date>;
    _datePicker: DatePickerInnerComponent;
    onChange: any;
    onTouched: any;
    config: DatepickerConfig;
    protected _now: Date;
    protected _activeDate: Date;
    constructor(config: DatepickerConfig);
    configureOptions(): void;
    onUpdate(event: Date): void;
    onSelectionDone(event: Date): void;
    onActiveDateChange(event: Date): void;
    writeValue(value: any): void;
    registerOnChange(fn: () => void): void;
    registerOnTouched(fn: () => void): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DatePickerComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DatePickerComponent, "datepicker", never, { "datepickerMode": "datepickerMode"; "showWeeks": "showWeeks"; "activeDate": "activeDate"; "initDate": "initDate"; "minDate": "minDate"; "maxDate": "maxDate"; "minMode": "minMode"; "maxMode": "maxMode"; "formatDay": "formatDay"; "formatMonth": "formatMonth"; "formatYear": "formatYear"; "formatDayHeader": "formatDayHeader"; "formatDayTitle": "formatDayTitle"; "formatMonthTitle": "formatMonthTitle"; "startingDay": "startingDay"; "yearRange": "yearRange"; "onlyCurrentMonth": "onlyCurrentMonth"; "shortcutPropagation": "shortcutPropagation"; "monthColLimit": "monthColLimit"; "yearColLimit": "yearColLimit"; "customClass": "customClass"; "dateDisabled": "dateDisabled"; "dayDisabled": "dayDisabled"; }, { "selectionDone": "selectionDone"; "activeDateChange": "activeDateChange"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBQcm92aWRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBEYXRlUGlja2VySW5uZXJDb21wb25lbnQgfSBmcm9tICcuL2RhdGVwaWNrZXItaW5uZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERhdGVwaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGVwaWNrZXIuY29uZmlnJztcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IERBVEVQSUNLRVJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogUHJvdmlkZXI7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBEYXRlUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKiBzZXRzIGRhdGVwaWNrZXIgbW9kZSwgc3VwcG9ydHM6IGBkYXlgLCBgbW9udGhgLCBgeWVhcmAgKi9cbiAgICBkYXRlcGlja2VyTW9kZTogc3RyaW5nO1xuICAgIC8qKiBkZWZhdWx0IGRhdGUgdG8gc2hvdyBpZiBgbmctbW9kZWxgIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQgKi9cbiAgICBpbml0RGF0ZTogRGF0ZTtcbiAgICAvKiogIG9sZGVzdCBzZWxlY3RhYmxlIGRhdGUgKi9cbiAgICBtaW5EYXRlOiBEYXRlO1xuICAgIC8qKiBsYXRlc3Qgc2VsZWN0YWJsZSBkYXRlICovXG4gICAgbWF4RGF0ZTogRGF0ZTtcbiAgICAvKiogc2V0IGxvd2VyIGRhdGVwaWNrZXIgbW9kZSwgc3VwcG9ydHM6IGBkYXlgLCBgbW9udGhgLCBgeWVhcmAgKi9cbiAgICBtaW5Nb2RlOiBzdHJpbmc7XG4gICAgLyoqIHNldHMgdXBwZXIgZGF0ZXBpY2tlciBtb2RlLCBzdXBwb3J0czogYGRheWAsIGBtb250aGAsIGB5ZWFyYCAqL1xuICAgIG1heE1vZGU6IHN0cmluZztcbiAgICAvKiogaWYgZmFsc2Ugd2VlayBudW1iZXJzIHdpbGwgYmUgaGlkZGVuICovXG4gICAgc2hvd1dlZWtzOiBib29sZWFuO1xuICAgIC8qKiBmb3JtYXQgb2YgZGF5IGluIG1vbnRoICovXG4gICAgZm9ybWF0RGF5OiBzdHJpbmc7XG4gICAgLyoqIGZvcm1hdCBvZiBtb250aCBpbiB5ZWFyICovXG4gICAgZm9ybWF0TW9udGg6IHN0cmluZztcbiAgICAvKiogZm9ybWF0IG9mIHllYXIgaW4geWVhciByYW5nZSAqL1xuICAgIGZvcm1hdFllYXI6IHN0cmluZztcbiAgICAvKiogZm9ybWF0IG9mIGRheSBpbiB3ZWVrIGhlYWRlciAqL1xuICAgIGZvcm1hdERheUhlYWRlcjogc3RyaW5nO1xuICAgIC8qKiBmb3JtYXQgb2YgdGl0bGUgd2hlbiBzZWxlY3RpbmcgZGF5ICovXG4gICAgZm9ybWF0RGF5VGl0bGU6IHN0cmluZztcbiAgICAvKiogZm9ybWF0IG9mIHRpdGxlIHdoZW4gc2VsZWN0aW5nIG1vbnRoICovXG4gICAgZm9ybWF0TW9udGhUaXRsZTogc3RyaW5nO1xuICAgIC8qKiBzdGFydGluZyBkYXkgb2YgdGhlIHdlZWsgZnJvbSAwLTYgKDA9U3VuZGF5LCAuLi4sIDY9U2F0dXJkYXkpICovXG4gICAgc3RhcnRpbmdEYXk6IG51bWJlcjtcbiAgICAvKiogbnVtYmVyIG9mIHllYXJzIGRpc3BsYXllZCBpbiB5ZWFyIHNlbGVjdGlvbiAqL1xuICAgIHllYXJSYW5nZTogbnVtYmVyO1xuICAgIC8qKiBpZiB0cnVlIG9ubHkgZGF0ZXMgZnJvbSB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBtb250aCB3aWxsIGJlIHNob3duICovXG4gICAgb25seUN1cnJlbnRNb250aDogYm9vbGVhbjtcbiAgICAvKiogaWYgdHJ1ZSBzaG9ydGN1dGBzIGV2ZW50IHByb3BhZ2F0aW9uIHdpbGwgYmUgZGlzYWJsZWQgKi9cbiAgICBzaG9ydGN1dFByb3BhZ2F0aW9uOiBib29sZWFuO1xuICAgIC8qKiBudW1iZXIgb2YgbW9udGhzIGRpc3BsYXllZCBpbiBhIHNpbmdsZSByb3cgb2YgbW9udGggcGlja2VyICovXG4gICAgbW9udGhDb2xMaW1pdDogbnVtYmVyO1xuICAgIC8qKiBudW1iZXIgb2YgeWVhcnMgZGlzcGxheWVkIGluIGEgc2luZ2xlIHJvdyBvZiB5ZWFyIHBpY2tlciAqL1xuICAgIHllYXJDb2xMaW1pdDogbnVtYmVyO1xuICAgIC8qKiBhcnJheSBvZiBjdXN0b20gY3NzIGNsYXNzZXMgdG8gYmUgYXBwbGllZCB0byB0YXJnZXRlZCBkYXRlcyAqL1xuICAgIGN1c3RvbUNsYXNzOiB7XG4gICAgICAgIGRhdGU6IERhdGU7XG4gICAgICAgIG1vZGU6IHN0cmluZztcbiAgICAgICAgY2xheno6IHN0cmluZztcbiAgICB9W107XG4gICAgLyoqIGFycmF5IG9mIGRpc2FibGVkIGRhdGVzICovXG4gICAgZGF0ZURpc2FibGVkOiB7XG4gICAgICAgIGRhdGU6IERhdGU7XG4gICAgICAgIG1vZGU6IHN0cmluZztcbiAgICB9W107XG4gICAgLyoqIGRpc2FibGVkIGRheXMgb2YgdGhlIHdlZWsgZnJvbSAwLTYgKDA9U3VuZGF5LCAuLi4sIDY9U2F0dXJkYXkpICovXG4gICAgZGF5RGlzYWJsZWQ6IG51bWJlcltdO1xuICAgIC8qKiBjdXJyZW50bHkgYWN0aXZlIGRhdGUgKi9cbiAgICBhY3RpdmVEYXRlOiBEYXRlO1xuICAgIHNlbGVjdGlvbkRvbmU6IEV2ZW50RW1pdHRlcjxEYXRlPjtcbiAgICAvKiogY2FsbGJhY2sgdG8gaW52b2tlIHdoZW4gdGhlIGFjdGl2ZURhdGUgaXMgY2hhbmdlZC4gKi9cbiAgICBhY3RpdmVEYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RGF0ZT47XG4gICAgX2RhdGVQaWNrZXI6IERhdGVQaWNrZXJJbm5lckNvbXBvbmVudDtcbiAgICBvbkNoYW5nZTogYW55O1xuICAgIG9uVG91Y2hlZDogYW55O1xuICAgIGNvbmZpZzogRGF0ZXBpY2tlckNvbmZpZztcbiAgICBwcm90ZWN0ZWQgX25vdzogRGF0ZTtcbiAgICBwcm90ZWN0ZWQgX2FjdGl2ZURhdGU6IERhdGU7XG4gICAgY29uc3RydWN0b3IoY29uZmlnOiBEYXRlcGlja2VyQ29uZmlnKTtcbiAgICBjb25maWd1cmVPcHRpb25zKCk6IHZvaWQ7XG4gICAgb25VcGRhdGUoZXZlbnQ6IERhdGUpOiB2b2lkO1xuICAgIG9uU2VsZWN0aW9uRG9uZShldmVudDogRGF0ZSk6IHZvaWQ7XG4gICAgb25BY3RpdmVEYXRlQ2hhbmdlKGV2ZW50OiBEYXRlKTogdm9pZDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZDtcbn1cbiJdfQ==